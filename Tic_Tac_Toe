#include <iostream>
#include <vector>
#include <string>

// --- Constants ---
const int BOARD_SIZE = 3;

// The game board, initialized with space characters
char board[BOARD_SIZE][BOARD_SIZE] = {
    {' ', ' ', ' '},
    {' ', ' ', ' '},
    {' ', ' ', ' '}
};

// Global variable to track the current player
char currentPlayer = 'X';
int turnCount = 0;


// --- Function Declarations ---
void drawBoard();
bool checkWin();
bool checkDraw();
void switchPlayer();
void getPlayerMove();


// --- Function Implementations ---

/**
 * @brief Clears the console and draws the current state of the board.
 */
void drawBoard() {
    // A simple way to clear the console output (may not work on all terminals)
#ifdef _WIN32
    system("cls");
#else
    system("clear");
#endif

    std::cout << "\n    Tic-Tac-Toe Game (C++ Console)\n\n";
    std::cout << "      1   2   3\n";
    std::cout << "    -------------" << std::endl;
    for (int i = 0; i < BOARD_SIZE; ++i) {
        std::cout << "  " << (char)('A' + i) << " |";
        for (int j = 0; j < BOARD_SIZE; ++j) {
            std::cout << " " << board[i][j] << " |";
        }
        std::cout << "\n    -------------" << std::endl;
    }
    std::cout << "\n";
}

/**
 * @brief Checks all win conditions (rows, columns, and two diagonals).
 * @return True if the current player has won, False otherwise.
 */
bool checkWin() {
    // Check rows and columns
    for (int i = 0; i < BOARD_SIZE; ++i) {
        // Check row i
        if (board[i][0] == currentPlayer && board[i][1] == currentPlayer && board[i][2] == currentPlayer) {
            return true;
        }
        // Check column i
        if (board[0][i] == currentPlayer && board[1][i] == currentPlayer && board[2][i] == currentPlayer) {
            return true;
        }
    }

    // Check main diagonal (top-left to bottom-right)
    if (board[0][0] == currentPlayer && board[1][1] == currentPlayer && board[2][2] == currentPlayer) {
        return true;
    }

    // Check anti-diagonal (top-right to bottom-left)
    if (board[0][2] == currentPlayer && board[1][1] == currentPlayer && board[2][0] == currentPlayer) {
        return true;
    }

    return false;
}

/**
 * @brief Checks if the board is full.
 * @return True if all 9 turns have been played and no win occurred.
 */
bool checkDraw() {
    return turnCount == (BOARD_SIZE * BOARD_SIZE);
}

/**
 * @brief Switches the global current player ('X' to 'O', or 'O' to 'X').
 */
void switchPlayer() {
    currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';
}

/**
 * @brief Prompts the current player for a move and validates it.
 * The move is an alphanumeric string (e.g., "A1", "C3").
 */
void getPlayerMove() {
    std::string move;
    int row = -1, col = -1;
    bool validMove = false;

    while (!validMove) {
        std::cout << "Player " << currentPlayer << ", enter your move (e.g., A1, C3): ";
        std::cin >> move;

        // Ensure the input has exactly 2 characters
        if (move.length() != 2) {
            std::cout << "Invalid format. Enter a letter (A-C) and a number (1-3).\n";
            continue;
        }

        // Convert first char (A, B, C) to row index (0, 1, 2)
        char rowChar = std::toupper(move[0]);
        if (rowChar >= 'A' && rowChar <= 'C') {
            row = rowChar - 'A';
        }
        else {
            std::cout << "Invalid row coordinate. Use A, B, or C.\n";
            continue;
        }

        // Convert second char (1, 2, 3) to column index (0, 1, 2)
        char colChar = move[1];
        if (colChar >= '1' && colChar <= '3') {
            col = colChar - '1';
        }
        else {
            std::cout << "Invalid column coordinate. Use 1, 2, or 3.\n";
            continue;
        }

        // Check if the selected cell is already taken
        if (board[row][col] != ' ') {
            std::cout << "That spot is already taken. Try again.\n";
            continue;
        }

        // Move is valid
        validMove = true;
    }

    // Place the marker on the board and increment turn count
    board[row][col] = currentPlayer;
    turnCount++;
}

/**
 * @brief Main function to run the game loop.
 */
int main() {
    bool gameOver = false;

    while (!gameOver) {
        drawBoard();
        getPlayerMove();

        // After a move, check for win or draw
        if (checkWin()) {
            drawBoard(); // Draw final board state
            std::cout << "******************************************\n";
            std::cout << "           PLAYER " << currentPlayer << " WINS!           \n";
            std::cout << "******************************************\n";
            gameOver = true;
        }
        else if (checkDraw()) {
            drawBoard(); // Draw final board state
            std::cout << "******************************************\n";
            std::cout << "               IT'S A DRAW!               \n";
            std::cout << "******************************************\n";
            gameOver = true;
        }
        else {
            // If no win or draw, switch to the next player
            switchPlayer();
        }
    }

    return 0;
}
